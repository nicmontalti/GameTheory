# PYTHON SCRIPT CODE
# -*- coding: utf-8 -*-
"""game.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e5m0tdDFCutZ4L3wx_73H3v6ZhlCE4Uf
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import random
import time

M = 50
N = 50


def abstein_choice(game):
    if game == 'pd' or game == 'sd':
        A = np.zeros((M, N))
    elif game == 'pdpa' or game == 'sdpa':
        A = np.floor(np.random.rand(M, N) * 8)/8
    elif game == 'opd' or game == 'osd':
        A = (np.random.rand(M, N) < 0.5).astype('int')
    else:
        A = np.zeros()
    return A

# matrix of payoff


def neumann(i, j):
    left = (i - 1) % M
    right = (i + 1) % M
    up = (j + 1) % N
    down = (j - 1) % N
    result = [(left, j), (right, j), (i, up), (i, down)]
    random.shuffle(result)
    return result

# payoff after a game played


def play(g1, g2, a1, a2):
    # if one of the two players doesn't play => both don't play
    if np.random.rand() < a1 or np.random.rand() < a2:
        return L, L
    else:
        if g1 == 0 and g2 == 0:
            return R, R
        elif (g1 == 0 and g2 == 1):
            return S, T
        elif (g1 == 1 and g2 == 0):
            return T, S
        elif (g1 == 1 and g2 == 1):
            return P, P


def play_a_turn(G, A):
    # evaluation of payoffs
    payoff = np.zeros((M, N))
    for j in range(M):
        for i_ in range(int(N/2)):
            i = j % 2 + i_ * 2
            neighbours = neumann(i, j)
            for neighbour in neighbours:
                pay1, pay2 = play(
                    G[i, j], G[neighbour[0], neighbour[1]], A[i, j], A[neighbour[0], neighbour[1]])
                payoff[i, j] += pay1
                payoff[neighbour[0], neighbour[1]] += pay2
    return payoff


def imitate(G, A, payoff, noise=0):
    G1 = G.copy()
    A1 = A.copy()
    for i in range(N):
        for j in range(M):
            if np.random.rand() < noise:
                G1[i, j] = 1 - G[i, j]
                # G1[i, j] = int(np.random.rand() < q)
            else:
                max = payoff[i, j]
                maxcoor = (i, j)
                for neighbour in neumann(i, j):
                    if payoff[neighbour[0], neighbour[1]] > max:
                        max = payoff[neighbour[0], neighbour[1]]
                        maxcoor = (neighbour[0], neighbour[1])
                # if maxcoor != (i,j):
                G1[i, j] = G[maxcoor[0], maxcoor[1]]
                A1[i, j] = A[maxcoor[0], maxcoor[1]]

    return G1, A1


def play_for_given_T(T, game):
    # definition of matrix of players and probability of abstention
    G0 = np.random.randint(0, 2, (M, N))

    game = game
    noise = 0.001

    global R, S, P, L

    _, R, S, P, L = game_choice(game)
    T = T
    A0 = abstein_choice(game)

    G = G0.copy()
    A = A0.copy()

    time = 100

    for t in range(time):
        payoff = play_a_turn(G, A)
        G, A = imitate(G, A, payoff, noise)
        eps = (1-G)*(1-A)

    eps_mean = np.mean(eps)
    A_mean = np.mean(A)

    return eps_mean, A_mean


def alpha_eps():
    iterations = 10
    Ts = np.linspace(1.1, 1.9, 9)
    games = ['pd', 'opd', 'pdpa']

    result = []

    for game in games:
        epsTmean = []
        ATmean = []
        epsTstd = []
        ATstd = []
        global T
        for T in Ts:
            epss = []
            As = []
            for i in range(iterations):
                eps, A = play_for_given_T(T, game)
                epss.append(eps)
                As.append(A)

            epsTmean.append(np.mean(epss))
            ATmean.append(np.mean(As))
            epsTstd.append(np.std(epss))
            ATstd.append(np.std(As))
        result.append([epsTmean, epsTstd, ATmean, ATstd, Ts])

        timestr = time.strftime("%Y%m%d-%H%M%S")
    np.save('data/alpha_eps-'+timestr, result)


def evolution(game, noise=0, time=100, plot=False, TT=None):
    # definition of matrix of players and probability of abstention
    G0 = np.random.randint(0, 2, (M, N))

    global T, R, S, P, L
    if TT is None:
        T, R, S, P, L = game_choice(game)
    else:
        _, R, S, P, L = game_choice(game)
        T = TT

    A0 = abstein_choice(game)

    G = G0.copy()
    A = A0.copy()

    if plot:
        fig = plt.figure(figsize=(20, 7))
        axs = fig.subplots(1, 3)

        cmap_G = matplotlib.colors.ListedColormap(['tab:green', 'tab:red'])
        cmap_A = matplotlib.colors.LinearSegmentedColormap.from_list("", [
                                                                     'ivory', 'gold'])

        im_G = axs[0].imshow(G, cmap=cmap_G)
        im_A = axs[1].imshow(A, cmap=cmap_A)
        im_eps = axs[2].imshow((1-G)*(1-A), cmap='Blues')

        cbar = fig.colorbar(im_G, ax=axs[0], ticks=[
                            0.25, 0.75], fraction=0.03, pad=0.05)
        cbar.ax.set_yticklabels(['Coop', 'Defect'])
        fig.colorbar(im_A, ax=axs[1], fraction=0.03, pad=0.05)
        fig.colorbar(im_eps, ax=axs[2], fraction=0.03, pad=0.05)

        axs[0].set_title('Strategy')
        axs[1].set_title('Abstention')
        axs[2].set_title('Cooperation')

        plt.show(block=False)

    for t in range(time):
        if plot:
            fig.suptitle('R = {}, S = {}, T = {}, P = {}, L = {} \n Game: {}, noise = {} \n time={}'.format(
                R, S, T, P, L, game, noise, t))
        payoff = play_a_turn(G, A)
        G, A = imitate(G, A, payoff, noise)
        eps = (1-G)*(1-A)
        if plot:
            im_G.set_data(G)
            im_A.set_data(A)
            im_eps.set_data(eps)
            if t == time-1:
                plt.show(block=True)
            plt.pause(0.000000000001)

    return G, A


def get_histo(G, A):
    A_1 = A * G
    A_2 = A * (1-G)

    alphas = np.linspace(0, 1, 9)
    num_alpha = np.zeros(9)
    num_alpha2 = np.zeros(9)
    for index, alpha in enumerate(alphas):
        num_alpha[index] = np.sum(A_1 == alpha)
        num_alpha2[index] = np.sum(A_2 == alpha)
        # remove zeros given by the masks
        if index == 0:
            num_alpha[0] -= np.sum(G == 0)
            num_alpha2[0] -= np.sum(G == 0)

    alpha_mean_def = np.mean(A[G.astype(bool)])
    alpha_mean_coop = np.mean(A[np.logical_not(G.astype(bool))])
    # alpha_std_def = np.std(A[G.astype(bool)])
    # alpha_std_coop = np.std(A[np.logical_not(G.astype(bool))])

    ratio_mean = alpha_mean_coop / alpha_mean_def
    # ratio_std = np.sqrt((alpha_std_coop / alpha_mean_coop) ** 2 + (alpha_std_def / alpha_mean_def)**2) * ratio_mean

    return num_alpha / (M*N), num_alpha2 / (M*N), ratio_mean
    # print histo
    # alphas_edges = alphas - 0.125/2
    # alphas_edges = np.append(alphas_edges, [alphas_edges[-1] + 0.125])
    # fig = plt.figure()
    # ax = fig.add_subplot()
    # ax.plot(alphas, num_alpha / (M*N), marker='.', color='tab:red')
    # ax.plot(alphas, num_alpha2 / (M*N), marker='.', color='tab:green')
    # ax.set_xticks(alphas)
    # fig.savefig('histo.pdf')


def save_histo(game, noise=0.0, t=100, n=10):
    G, A = np.empty((M, N)), np.empty((M, N))
    stat_alpha1 = np.empty((n, 9))
    stat_alpha2 = np.empty((n, 9))

    for i in range(n):
        G, A = evolution(game, noise, t, plot=False)
        stat_alpha1[i, :], stat_alpha2[i, :], _ = get_histo(G, A)

    mean_1 = np.mean(stat_alpha1, axis=0)
    mean_2 = np.mean(stat_alpha2, axis=0)
    std_1 = np.std(stat_alpha1, axis=0)
    std_2 = np.std(stat_alpha2, axis=0)

    save = np.array([mean_1, std_1, mean_2, std_2, np.linspace(0, 1, 9)])

    timestr = time.strftime("%Y%m%d-%H%M%S")
    np.save('data/alpha-'+timestr, save)


def save_ratio_mean(game='pdpa', noise=0, t=200):
    iterations = 10
    Ts = np.linspace(1.1, 1.9, 9)

    result = []

    global T
    for T in Ts:
        ratio_means_iter = []
        # alpha_stds_iter = []
        for i in range(iterations):
            G, A = evolution(game, noise=noise, time=t, plot=False, TT=T)
            _, _, mean = get_histo(G, A)
            ratio_means_iter.append(mean)
            # alpha_stds_iter.append(std)
        # alpha_mean_T = np.sum(
        #    alpha_means_iter / np.array(alpha_stds_iter)**2) / np.sum(1/np.array(alpha_stds_iter)**2)
        # alpha_std_T = np.sqrt(1 / np.sum(1/np.array(alpha_means_iter)**2))
        ratio_mean_T = np.mean(ratio_means_iter)
        result.append([ratio_mean_T,  T])

    timestr = time.strftime("%Y%m%d-%H%M%S")
    np.save('data/alpha_mean-'+timestr, result)


def game_choice(game):
    L = 0
    if game == 'pd' or game == 'opd' or game == 'pdpa':
        T = 1.5
        R = 1
        S = 0
        P = 0.3
        L = 0.4

    elif game == 'sd' or game == 'osd' or game == 'sdpa':
        T = 1.4
        R = 1
        S = 0.2
        P = 0.
        L = 0.4

    elif game == 'sh':

        T = 8
        R = 1
        P = 5
        S = 1

    return T, R, S, P, L


if __name__ == '__main__':
    save_histo('pdpa', noise=0.001, t=200, n=10)

    # alpha_eps()

    # save_ratio_mean()
